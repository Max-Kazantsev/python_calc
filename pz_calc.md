## Практическое занятие №?. Изобретение ~~велосипеда~~ калькулятора (Декораторы)
### Рассматриваемые вопросы
1. Словари
2. Декораторы
3. Обратная польская нотация

*Можно информацию по декораторам дать здесь*

1. Написать функцию калькулятора, реализующего сложение двух чисел. 
Пользователь вводит "1 + 4", ему возвращается 5. Выход по вводу exit. 
**Замечание**: реализовать отдельно меню взаимодействия с пользователем и функцию сложения

2. Попробуем добавить оснонвые операции изучаемые до 5 класса: *, /, +, -.
**Подсказка**: можно использовать словарь вида {символ_операции: функция_операции}.
Также вспоминаем, что неплохо было бы разделить тело калькулятора и вынести операции в
соседний файл для чистоты кода


3. Одна операция за раз - слишком просто. Давайте попробуем научиться решать примеры вида
 "1 + 2 + 3" или "4 - 5 * 6" или что ещё страшнее "( 1 + 2 ) / ( 3 - 4) * 5". И в решении
 данной задачи нам поможет алгоритм обратной польской нотации (*можно дать готовую функцию
 считающую rpn либо же указать ссылку на материал по ней*). **Замечание**: очевидно, что для
 реализации правильного вычисления выражений, алгоритм должен знать приоритеты операций,
 которые необходимо добавить к словарю.

4. Добавить операции возведения в степень ** и нахождения корня root.

5. Заметим, что для добавления новых методов, расширяющих функционал словаря необходимо
каждый раз писать функцию, добавлять её в словарь, прописывать её приоритет и только после
этого всё начинает работать. Уже неудобно, т.к. операции и калькулятор находятся в разных
файлах. **Задача**: реализовать функцию, добавляющую новые операторы в словарь операций
калькулятора, учитывая их приоритет.

6. На самом деле такое решение вопроса пришло в голову не только нам. Для облегчения
выполнения рутинных операций для различных объектов в Python существуют декораторы:

```python
def my_decorator(func):
    def wrapper():
        print("Что-то, что происходит перед вызовом функции")
        func()
        print("Что-то, что происходит после вызова функции")
    return wrapper

@my_decorator
def say_whee():
    print("Что здесь происходит?")
```
Такой вид декораторов определяет, что будет вызвано до и после декорируемой функции, что
можно использовать для красивого выделения своих строк при выводе в консоль. Но в настоящий
момент нас интересуют декораторы не связнные с вызовом функции:

```python
import random
DIVINATIONS = {}

def add_divination(func):
    """ Добавить новое предсказание """
    DIVINATIONS[func.__name__] = func
    return func

@add_divination
def excellent_day(name):
    return f"Сегодня отличный день для людей с именем {name}"

@add_divination
def calm_down(name):
    return f"Да закроешь ты эту сессию, {name}, нормально всё будет!"

def see_future(name):
    greeter, greeter_func = random.choice(list(DIVINATIONS.items()))
    print(f"Using {greeter!r}")
    return greeter_func(name)
```
Данный пример иллюстрирует как можно изменять поведение функции ещё в момент её объявления.
В частности, на данном принципе основывается добавление путей в Flask.


**Задание**: Реализовать калькулятор, расширяемый за счёт модулей, добавляемых при помощи
декоратора.